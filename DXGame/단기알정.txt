










정보창 UI 획득 UI 1일


저주 획득

체력 획득 소울 획득 이펙트




맵이동  정보 남기기 

데미지 표기 1일


정보값 입력 데미지 수치 체력 등
 
어두운부분 추가 1일

벽에 안에 파고드는 것 수정

시작맵 제작 기본 사진에 애니메이션 귀신 추가

맵추가 제작 2일

카메라 수정 카메라 흔들림 


궁극기 1일

 

사운드 3일

시간 남으면 

강공격
강대쉬

사다리

대쉬 이펙트




완료

체력감소 효과 

피격효과


로딩화면 

몬스터 피격 넉백 이펙트

몬스터 출현 기믹
페이퍼월 
픽셀충돌로 이동막기
몬스터도
이펙트추가
다죽었는지 체크하고 보상 출현

플레이 UI 미지수

시작화면 1시간



아이템 획득

무기 제작 3일

광원 그림자

공격마다 피봇설정을 달리해서 어색함없이 피봇이 작동하게 만들기 
기본값을 중앙으로 두기 공격할떄 아이들값의 절반 만큼 비율을 계산해서 피봇에 곱해주는 방식?

대쉬 함수
피봇값 애니 데이터에 넣고 체인지마다 적용되게 만들기
플립될때 피봇에 맞게 위치값 바꾸기


몬스터
고스트우먼
따라다니는 책

피격판정
슈퍼아머

배경맵 오브젝트 배치용 GUI 제작

골리전 처리
배경맵 원근감 만들기
몬스터 배경맵 배치

보스맵 제작

보스

맵 포토샵제작



치유 공이 목표물을 향해 이동하고 목표물 주위를 선회한 다음 당겨지는 보다 역동적이고 시각적으로 흥미로운 효과를 얻으려면 공과 목표물 사이의 선에 수직인 방향에 초기 속도를 추가하여 궤도를 시뮬레이션할 수 있습니다.

다음은 이를 구현하는 간단한 방법입니다:

1. **목표물을 향한 초기 이동**: 치유 공을 집어 들었을 때 목표물을 향해 움직이되 옆으로 약간 움직입니다.

2. **궤도 돌기**: 목표물에 가까워질수록 옆으로 움직이는 동작을 줄이고 중력 방향으로 끌어당기는 힘을 높입니다.

3. **최종 당기기**: 궤도를 반 정도 돌고 나면 목표물을 향해 직접 당깁니다.

코딩 방법은 다음과 같습니다:

```cpp
#include <cmath>

void MoveHealingBall(HealingBall& ball, const XMFLOAT3& targetPosition, float deltaTime) {
    static const float GRAVITY_PULL = 10.0f; // 중력 당기는 힘
    static const float ORBITAL_RADIUS = 5.0f; // 원하는 반궤도 반경
    static bool inOrbit = false; // 궤도 상태 플래그

    XMVECTOR ballPos = XMLoadFloat3(&ball.position);
    XMVECTOR targetPos = XMLoadFloat3(&targetPosition);
    
    // 공에서 타깃까지의 방향 계산
    XMVECTOR toTargetNormalized = XMVector3Normalize(XMVectorSubtract(targetPos, ballPos));
    
    if (ball.isPickedUp && !inOrbit) {
        // 치유 공에 toTarget에 수직인 초기 속도를 부여합니다.
        XMVECTOR orbitDirection = XMVector3Orthogonal(toTargetNormalized);
        float initialSpeed = 2.0f;
        ball.velocity = XMVectorAdd(ball.velocity, XMVectorScale(orbitDirection, initialSpeed));
        
        inOrbit = true;
    }
    
    if (inOrbit) {
        // 공에서 목표 위치까지의 거리를 계산합니다.
        float distanceToTarget = XMVectorGetX(XMVector3Length(XMVectorSubtract(ballPos, targetPos)));

        // 궤도 반경 내에 있으면 중력을 더 강하게 시뮬레이션하여 타깃을 향해 끌어당깁니다.
        if (distanceToTarget <= ORBITAL_RADIUS) {
            float pullStrength = GRAVITY_PULL / (distanceToTarget * distanceToTarget);
            pullStrength = std::min(pullStrength, GRAVITY_PULL); // 클램프 당김 강도
            
            // 목표를 향해 가속
            XMVECTOR gravityForce = XMVectorScale(toTargetNormalized, pullStrength * deltaTime);
            ball.velocity = XMVectorAdd(ball.velocity, gravityForce);
            
            if (distanceToTarget < 1.0f) {  
                // 타겟에 충분히 가까워져 궤도를 멈춥니다.
                inOrbit = false;
                ball.isPickedUp = false;
                ball.position = targetPosition;
            }
        }
    }

    // 속도에 따라 위치 업데이트
    ball.position += ball.velocity * deltaTime;

    // 궤도 붕괴를 위한 공간에서의 마찰/저항을 시뮬레이션하기 위해 속도를 감쇠시킵니다.
    float 댐핑팩터 = 0.99f; // 게임 느낌에 따라 필요에 따라 조정합니다.
    ball.velocity *= 댐핑팩터;
}
```

이 예제에서는
- inOrbit`은 힐링볼이 현재 궤도 경로에 있는지 여부를 나타내는 플래그입니다.
- 궤도 방향`은 `toTargetNormalized`에 직교하는 벡터를 찾아서 계산되며, 이는 치유 공과 목적지 사이의 시선에 수직인 방향을 제공합니다.
- 초기 속도`는 물체를 목적지 주위의 궤도로 이동시키기 위한 초기 발차기로 사용됩니다.
- 중력에 대한 역제곱 법칙은 단순화되어 `GRAVITY_PULL`로 고정됩니다.
- 감쇠 계수는 시간이 지남에 따라 속도를 감소시켜 궤도 붕괴처럼 보이게 하고 결국 목표 위치에 안착하게 합니다.

이 예제에서는 `HealingBall` 클래스 또는 구조체에 추가 프로퍼티(`velocity`)가 있다고 가정하고 벡터의 스칼라 덧셈과 곱셈을 처리하는 방법(`XMVectorAdd`, `XMVectorScale`)을 정의했음을 다시 한 번 확인합니다. 시각적 개연성과 재미있는 게임플레이를 위해 게임의 특정 요구사항에 따라 `initialSpeed`, `GRAVITY_PULL`, `dampingFactor`와 같은 상수를 조정해야 합니다.

이 함수는 매 프레임 업데이트마다 호출하며, 여기서 `deltaTime`은 마지막 프레임 이후 경과된 시간을 나타냅니다. 이렇게 하면 치유 공이 수집을 위해 당겨지기 전에 목적지에 가까워질 때 시각적으로 매력적인 호를 만들 수 있습니다.